
Adding New Atom and Value Types
===============================

The NameServer provides a primitive extension mechanism so that
modules/agents/libraries may add new atom types to the default type
hierarchy. In order to ease the task of third-parties wishing to extend
the NameServer, we provide a cmake macro that generates a set of
files with c++ code that can be used by the module/library.

Declaring a new Value or Atom type
----------------------------------
The macro uses a 'type script' file as input which uses the following
format:
```
<TYPE> [<- <PARENT_TYPE1>[,<PARENT_TYPE2>,<PARENT_TYPE3>,...]] ["<TYPE_NAME>"]
```
Where

 * `TYPE` is an identifier that will be used in your code to reference
   the type's numeric code. Usually, it is defined using capital
   letters and underscores as its semantics is close to that of C/C++
   constant.

 * `PARENT_TYPE1, PARENT_TYPE1, PARENT_TYPE2` are optional identifiers of
   the parent types of the defined type. When more than one parent type
   is specified, they must be separated by commas.

 * `TYPE_NAME` is a string that will be used to identify the type. If
   none is supplied, the cmake macro will generate one based on the
   type's identifer using camel-casing patterns (for instance,
   `CUSTOM_NODE` would be named `CustomNode`).

Above is a short snippet of valid script entries. For more examples,
check the `atom_types.script` file in this directory.
```
ATOM
NODE <- ATOM
LINK <- ATOM
WORD_NODE <- NODE
CONCEPT_NODE <- NODE "OddlyNamedNode"
ASSOCIATIVE_LINK <- LINK "AssocL"
EVALUATION_LINK <- LINK "EvalLink"
MULTIPARENT_LINK <- ASSOCIATIVE_LINK_LINK,EVALUATION_LINK "MPLink"
```
-----

CMake and autogenerated files
-----------------------------
To process the `atom types` script file, one must add the macro
`OPENCOG_ADD_ATOM_TYPES` to the `CMakeLists.txt` and the header file
to the list of source files:

```
# CMakeList.txt
OPENCOG_ADD_ATOM_TYPES(atom_types.script atom_types.h atom_types.definitions atom_types.inheritance)

ADD_LIBRARY(sample
    atom_types.h
    Sample1.cc
    Sample2.cc
    ...
)
```
The macro `OPENCOG_ADD_ATOM_TYPES` expects 4 parameters:

1. The filename of the script file that will be used as input
2. The filename of the header file that will be generated with
   the identifiers of the new atom types.
3. The filename of the definitions file that will be generated with
   the instantiations of the variables that will store the new atom
   types.
4. The filename of the inheritance file that will be generated with
   the set of method invocations that will build the type hierarchy
   inside the NameServer.

Creating a shared library with the types in them
------------------------------------------------
To properly *use* the generated files, the following conventions should be
followed:

  * Include the definitions file right after the standard `#include`
    statement of the file with the code that initializes your
    module/agent/library.

  * Include the inheritance file *inside the body* of the routine
    initializing the module/agent/library.

  * Include the header file by any files that references the identifier
    of the a new atom type.

For instance:
```
// MyModule.cc
#include "MyModule.h"
#include "AnotherHeader.h"
#include "atom_types.definitions"
MyModule::MyModule() {}
...
static __attribute__ ((constructor)) void _init(void)
{
    #include "atom_types.inheritance"
}


// AnotherFile.cc
#include "AnotherFile.h"
#include "atom_types.h"
#include "YetAnotherFile.h"

void AnotherFile::someMethod() {
    ...
    std::string name = opencog::NameServer::getTypeName(opencog::MYNODE);
    ...
}
```
